# 2016
# Author: Aaron Watkins

import os
import time
import MIDI
import Adafruit_CharLCD as LCD
import LEDs as ROUTING
import RotaryEncoder as ROT_ENC
import Menu as MENU

display = LCD.Adafruit_CharLCDPlate()
routing = ROUTING.Looper_LEDsPlate()
mainMenu = MENU.MainMenu()
globalMenu = MENU.GlobalMenu()

class Pedal(object):
    
    def __init__(self, name, state, type):
        self.name = name
	self.type = type
	self.isEngaged = state
	if self.isEngaged:
	    self.turnOn()
	else:
	    self.turnOff()	


class ButtonOnPedalBoard(Pedal):

    EXP_TIP_1 = 6
    TAP_RING_2 = 7

    def __init__(self, name, state, button, type, FuncTwoType, FuncTwoPort):
	self.button = button
	self.start = time.time()
	self.pin = self.fromButtonToPin(self.button)
	self.FuncTwoPort = FuncTwoPort
	self.FuncTwoType = FuncTwoType
        self.isPressed = False
	self.partner = None
	self.releaseTime = 0
	super(ButtonOnPedalBoard, self).__init__(name, state, type)

    def fromButtonToPin(self, button):
        if button < 6:
            return button - 1
        elif button < 11:
	    return button + 2
	else:
	    return button

    def partnerButtonPressed(self, intCapturePinVal):
        if not intCapturePinVal:
            self.isPressed = True
        else:
            self.isPressed = False
	    self.releaseTime = time.time()

    def setPartner(self, partner):
	self.partner = partner

    def getPartnerButton(self):
        if self.button < 6:
            return self.button + 5
        elif self.button < 11:
            return self.button - 5

    def secondaryFunction(self):
	portPin = self.getPortPin()
	if self.FuncTwoType == "Momentary":
	    routing.changeOutputPinState(portPin)
	    time.sleep(0.1)
	    routing.changeOutputPinState(portPin)
	elif self.FuncTwoType == "Latching":
	    routing.changeOutputPinState(portPin)
	elif self.FuncTwoType == "Settings":
            print "Settings"
	else:	
	    print "None " + str(self.button)

    def getPortPin(self):
	if self.FuncTwoPort == "EXP_TIP_1":
	    return self.EXP_TIP_1
	elif self.FuncTwoPort == "TAP_RING_2":
	    return self.TAP_RING_2

    def setSecondaryFunction(self, FuncTwoType, FuncTwoPort):
        self.FuncTwoPort = FuncTwoPort
        self.FuncTwoType = FuncTwoType

    def turnOn(self):
	routing.output(self.pin, False)
        self.isEngaged = True

    def turnOff(self):
	routing.output(self.pin, True)
        self.isEngaged = False

    def getPin(self):
        return self.pin


class TapTempoButton(ButtonOnPedalBoard):
    
    MIDITempoPedal = None
 
    def __init__(self, name, button, tempo, midiTempoPed):
	self.MIDITempoPedal = midiTempoPed
	type = "TapTempoButton"
	state = True
	FuncTwoType = "None"
	FuncTwoPort = "None"
	super(TapTempoButton, self).__init__(name, state, button, type, FuncTwoType, FuncTwoPort)
	self.lastTap = time.time() - 2.5 #because the last tap being more than 2.5s ago means "start over"
	self.avgTapTime = 0 #only to start with
	self.TapNum = 0
	self.setTempo(tempo)

    def setTempo(self, tempo):
	if tempo > 99.9:
	    self.tempo = int(tempo)
	else:
            self.tempo = tempo
	sleepTime = 60.0/self.tempo #seconds/beat
        for num in range(0,4):
	    self.start = time.time()
	    self.turnOff()
	    time.sleep(0.05)
	    self.turnOn()
	    time.sleep(sleepTime - (time.time() - self.start)) 

    def getTempo(self):
	return self.tempo	

    def buttonState(self, intCapturePinVal):
        if not intCapturePinVal:
	    self.turnOff()
	    self.MIDITempoPedal.tapTempo()
            self.isPressed = True
	    self.start = time.time()
	    self.calculateTempo()
        else:
	    self.turnOn()
   	    if self.TapNum > 4:
		time.sleep(self.avgTapTime)
		self.setTempo(int(10 * (60 / self.avgTapTime)) / 10.0 )	    
		if self.MIDITempoPedal is not None:
		    self.MIDITempoPedal.setTempo(self.tempo)
            self.isPressed = False

    def calculateTempo(self):
	if (time.time() - self.lastTap) > 2.5: #no need to go less than 24 BPM
	    self.TapNum = 0
	elif self.TapNum == 1:
	    self.TapTime1 = time.time() - self.lastTap
	elif self.TapNum == 2:
            self.TapTime2 = time.time() - self.lastTap
	elif self.TapNum == 3:
            self.TapTime3 = time.time() - self.lastTap
	else:
	    self.TapTime1 = self.TapTime2
	    self.TapTime2 = self.TapTime3
	    self.TapTime3 = time.time() - self.lastTap
	    self.avgTapTime = (self.TapTime1 + self.TapTime2 + self.TapTime3) / 3.0	    	
	self.TapNum += 1    
	self.lastTap = time.time()


class LoopPedal(ButtonOnPedalBoard):

    def __init__(self, name, button, state, FuncTwoType, FuncTwoPort):
	type = "LoopPedal"
	super(LoopPedal, self).__init__(name, state, button, type, FuncTwoType, FuncTwoPort)
	    	
    def buttonState(self, intCapturePinVal):
	if not intCapturePinVal:
	    self.isPressed = True
	    self.start = time.time()
	else:
	    self.end = time.time()
            deltaT = self.end - self.start
	    if not self.isEngaged:
          	self.turnOn()
            else:
                if deltaT < 0.5:
              	    self.turnOff()
            	else:
                    self.secondaryFunction()
	    self.isPressed = False


class MidiLoopPedal(LoopPedal):

    SelahCommands = {"DATA_BYTE":"\x0F", "TS808_CLIP_CC":"\x50", "PLEXI_CLIP_CC":"\x51", "KLONE_CLIP_CC":"\x52", "ENGAGE_CC":"\x64", "BYPASS_CC":"\x65", "CYCLE_CLIP_CC":"\x5D", "TOGGLEBYPASS_CC":"\x66"}
    
    def __init__(self, name, pin, state, preset, MIDIchannel, FuncTwoType, FuncTwoPort, brand):
	self.type = "MidiLoopPedal"
        self.brand = brand
	self.preset = preset
	self.MIDIchannel = MIDIchannel
	self._midi = MIDI.MIDI(self.MIDIchannel) 
	if self.brand == "Selah":
            self.MidiCommandDict = self.SelahCommands
	    self.setSelahPreset(self.preset)
	super(MidiLoopPedal, self).__init__(name, pin, state, FuncTwoType, FuncTwoPort)
	
    def turnOn(self):
        #turn on via MIDI
        self._midi.MIDI_CC_TX(self.MidiCommandDict["ENGAGE_CC"], self.MidiCommandDict["DATA_BYTE"])
        self.isEngaged = True

    def turnOff(self):
        #turn off via MIDI
	self._midi.MIDI_CC_TX(self.MidiCommandDict["BYPASS_CC"], self.MidiCommandDict["DATA_BYTE"])
        self.isEngaged = False

    def setSelahPreset(self, preset):
	self.preset = preset
	if preset == "Plexi":
	    self._midi.SelahPresetChange(self.MidiCommandDict["PLEXI_CLIP_CC"], self.MidiCommandDict["DATA_BYTE"])		
	if preset == "TS808":
	    self._midi.SelahPresetChange(self.MidiCommandDict["TS808_CLIP_CC"], self.MidiCommandDict["DATA_BYTE"])		
	if preset == "Klone":
	    self._midi.SelahPresetChange(self.MidiCommandDict["KLONE_CLIP_CC"], self.MidiCommandDict["DATA_BYTE"])		

    def secondaryFunction(self):
        if self.FuncTwoType == "MIDI":
            self._midi.MIDI_CC_TX(self.MidiCommandDict[self.FuncTwoPort], self.MidiCommandDict["DATA_BYTE"])
        else:
            super(MidiLoopPedal, self).secondaryFunction()


class MidiNonLoopPedal(Pedal):
    #Strymon Pedals are the only Pedals not routed through the looper
    StrymonCommands = {"DATA_BYTE_ON":"\x7F", "DATA_BYTE_OFF":"\x00", "DATA_BYTE":"\x0F", "PRESET_GROUP_0":"\x00\x00", "PRESET_GROUP_1":"\x00\x01", "PRESET_GROUP_2":"\x00\x02", "ENGAGE_CC":"\x66", "BYPASS_CC":"\x66", "TAP_CC":"\x5D", "TOGGLEBYPASS_CC":"\x1D"}

    def __init__(self, name, state, MIDIchannel, brand, preset):
        type = "MidiNonLoopPedal"
	self.brand = brand
	self.MIDIchannel = MIDIchannel
	self._midi = MIDI.MIDI(MIDIchannel)
	self.preset = preset
        if self.brand == "Strymon":
            self.MidiCommandDict = self.StrymonCommands
	    self.setStrymonPreset(self.preset)
	super(MidiNonLoopPedal, self).__init__(name, state, type) 
	
    def turnOn(self):
	#turn on via MIDI
        self._midi.MIDI_CC_TX(self.MidiCommandDict["ENGAGE_CC"], self.MidiCommandDict["DATA_BYTE_ON"])
	self.isEngaged = True

    def turnOff(self):
        #turn off via MIDI
        self._midi.MIDI_CC_TX(self.MidiCommandDict["BYPASS_CC"], self.MidiCommandDict["DATA_BYTE_OFF"])
        self.isEngaged = False
	
    def setStrymonPreset(self, preset):
	presetGroup = preset / 128
	preset = preset % 128
	self._midi.StrymonPresetChange(self.MidiCommandDict["PRESET_GROUP_" + str(presetGroup)], chr(preset))	
	    	

class TimeLine(MidiNonLoopPedal):
    
    TimeLineSysExTempoStart = "\xF0\x00\x01\x55\x12\x01\x6F\x00\x00\x00" 
    TimeLineSysExEnd= "\xF7"

    def __init__(self, name, state, MIDIchannel, brand, tempo, preset):
	self.type = "TimeLine"
	self.tempo = tempo
	super(TimeLine, self).__init__(name, state, MIDIchannel, brand, preset)
	self.setTempo(self.tempo)

    def setTempo(self, tempo):
	#set tempo via MIDI
	self.delayInMs = int(60000/tempo)
	self._midi.SysEx_TX(self.TimeLineSysExTempoStart + chr(self.delayInMs//128) + chr(self.delayInMs%128) + self.TimeLineSysExEnd)

    def tapTempo(self):
	self._midi.MIDI_CC_TX(self.MidiCommandDict["TAP_CC"], self.MidiCommandDict["DATA_BYTE"])
	    


class Empty(ButtonOnPedalBoard):

    def __init__(self, name, button, state):
	type = "Empty"
	FuncTwoType = "None"
	FuncTwoPort = "None"
        super(Empty, self).__init__(name, state, button, type, FuncTwoType, FuncTwoPort)

    def buttonState(self, intCapturePinVal):
        if not intCapturePinVal:
            self.isPressed = True
        else:
            self.isPressed = False


class RotaryPushButton(ButtonOnPedalBoard):

    def __init__(self, button, state):
	type = "RotaryPushButton"
	FuncTwoType = "Settings"
	FuncTwoPort = "None"
	name = "RotaryPB"
	self._encoder = ROT_ENC.Rotary_Encoder()
        super(RotaryPushButton, self).__init__(name, state, button, type, FuncTwoType, FuncTwoPort)
	self.changeToMenu(mainMenu)
	self.lastRotaryTurn = 0

    def buttonState(self, intCapturePinVal):
        if not intCapturePinVal:
            self.isPressed = True
            self.start = time.time()
        else:
            self.end = time.time()
            deltaT = self.end - self.start
            if deltaT < 0.5:
		self.currentMenu.menuFunction(self.currentMenu.getMenuItemString())
#  	        if not self.isEngaged:
#                    self.turnOn() #this switched all leds to red/blue
#                else:
#                    self.turnOff() #this switched all leds to red/blue
	    elif deltaT < 2:
                self.secondaryFunction()
            else:
		if deltaT > 10:
		    display.clear()
                    display.message("Goodbye.")
                    time.sleep(1)
		    os.system('shutdown now -h')
		    
		if self.currentMenu == mainMenu:
		    self.changeToMenu(globalMenu)
		else:
		    display.clear()
		    display.message("Saving...")
		    time.sleep(1)		    		    
		    self.changeToMenu(mainMenu)
            self.isPressed = False

    def changeToMenu(self, newMenu):
	self.currentMenu = newMenu
        self.currentMenu.menuPos = 0
	self.currentMenu.displayMenuItem()	

    def getRotaryMovement(self, a, b):
	direction = self._encoder.rotaryMovement(a, b)
	if time.time() - self.lastRotaryTurn > 0.10:
	    self.currentMenu.changeMenuPos(direction)
	    self.lastRotaryTurn = time.time()

